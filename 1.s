
add $t0, $zero, $zero #ο καταχωρητής $t0 αντιστοιχείvστη μεταβλητή count η οποίαvέχει μηδενική τιμή
addi $s2, $s0, 20 #η διεύθυνση του 6ου στοιχείου του πίνακα βρίσκεται 20(=5*4) bytes μετά τη διεύθυνση του πρώτου στοιχείου η οποία είναι αποθηκευμένη στον $s0
addi $s3, $s1, 40 #ομοίως με την προηγούμενη εντολή
LOOP: lw $t1, 0($s2) #αποθηκεύω το περιεχόμενο της διεύθυνσης που περιέχεται στον καταχωρητή $s2, δηλαδή το array1[5], στον καταχωρητή $t1.
      lw $t2, 0($s3) #ομοίως με προηγούμενη εντολή
      slt $t3, $t2, $t1 # αν το περιεχόμενο του $t1, δηλαδή το *x, είναι μεγαλύτερο του περιεχομένου του $t2, δηλαδή το *y, τοτε το περιεχόμενο του $t3 ισούται με 1.
      beq $t3, $zero, else # Αν το $t3 ισούται με $zero πήγαινε στο else
      add $t1, $t1, $t2 #προσθέτω τα περιεχόμενα των καταχωρητών $t1 και $t2 και αποθήκευσέ τα εκ νέου στον $t1
      sw $t1, 0($s2) #αποθηκεύω το περιεχόμενο του καταχωρητή $t1 στη διεύθυνση 0($s2)
      jmp next #πήγαινε στο next
else: sub $t2, $t2, $t1 #αφαιρώ το περιεχόμενο του #t1 από αυτό του $t2 και αποθηκεύω το αποτέλεσμα εκ νέου στο $t2.
      sw $t2, 0($s3) αποθηκεύω το περιεχόμενο του #t2 στον $s3, οπότε *y=*y-*x
next: addi $s2, $s2, 4 #πηγαίνω στην διεύθυνση της λέξης που είναι μετά το x
      addi $s3, $s3, 4 #πηγαίνω στην διεύθυνση της λέξης που είναι μετά το y
      addi $t0, $t0, 1 #αυξάνω το περιεχόμενο του $t0, δηλαδή τη μεταβλητή counter, κατά ένα
      subi $t5, t0 , 10 #αφαιρώ 10 από το περιεχόμενο του $t0 και αποθηκεύω το αποτέλεσμα στον καταχωρητή $t5.
      bne $t5, $zero, LOOP #Αν το περιεχόμενο του $t5 δεν ισούται με 0 πάω ξανά στο LOOP.
